// Company         :   kip
// Author          :   Stefan Philipp            
// E-Mail          :   philipp@kip.uni-heidelberg.de
//                    			
// Filename        :   tm_ramtest.cpp
// Project Name    :   p_facets
// Subproject Name :   s_hicann1            
//                    			
// Create Date     :   3/2009
//------------------------------------------------------------------------

#define USE_HICANN 0

#include <stdio.h>
#include "common.h"

#ifdef NCSIM
#include "systemc.h"
#endif

#include "hicann_ctrl.h"
#include "testmode.h" 

// jtag
//#include "verification_control.h"

//only if needed
#include "l1switch_control.h" //layer 1 switch control class
#include "neuron_control.h" //neuron control class (merger, background genarators)
#include "dnc_control.h"
#include "spl1_control.h" //spl1 control class

using namespace std;
using namespace facets;

class TmTimeStampTest : public Testmode {
protected:
	virtual string ClassName() {stringstream ss; ss << "tmag_timestamp_test"; return ss.str();}
public:

	FILE* pFile;
	HicannCtrl *hc; 
	NeuronControl *nc; //neuron control
	SPL1Control *spc;
	DNCControl  *dc;

	// -----------------------------------------------------	
	// test function
	// -----------------------------------------------------	

	//generate an SPL1 event (27 bits)
	uint64_t gen_spl1(uint channel, uint number, uint time){
		return ((channel & 0x7) << 21) | ((number & 0x3f) << 15) | (time & 0x7fff);
	}
	
	//generate an FPGA event packet (64 bits)
	uint64_t gen_fpga(uint64_t event1, uint64_t event2){
		return 0x8000000000000000 | (event2 << 32) | event1;
	}

	bool test() 
    {
		if ((chip.size()<FPGA_COUNT+DNC_COUNT) || !chip[FPGA_COUNT+DNC_COUNT]) {
		 	dbg(0) << "ERROR: object 'chip' in testmode not set, abort" << endl;
			return 0;
		}
		if (!jtag) {
		 	dbg(0) << "ERROR: object 'jtag' in testmode not set, abort" << endl;
			return 0;
		}
		uint hicannr = 0;
		// use HICANN number 0 (following FPGA and DNC in address space) for this testmode
		hc = (HicannCtrl*) chip[FPGA_COUNT+DNC_COUNT+hicannr];
		
		// obtain pointers
		nc  = &hc->getNC();
		spc = &hc->getSPL1Control(); // get pointer to SPL1 Control
		dc = (DNCControl*) chip[FPGA_COUNT]; // use DNC


		// ----------------------------------------------------
		// some local variables...
		// ----------------------------------------------------

		uint pulse_dist = 11; // fixed distance between pulses generated by background generators
		
		// initialize neuron numbers
		uint mynrns[] = {0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17};
		
		bool result = true;

		uint ms = 0x01;
		uint ns = 0x02;
		uint pdn = 0x1;
		uint frg = 0x1;
		uint tst = 0x0;

		// ----------------------------------------------------
		// initialize communication
		// ----------------------------------------------------

		// test JTAG ID
		uint64_t jtagid=0xf;
		jtag->read_id(jtagid,jtag->pos_hicann);
		cout << "HICANN ID: 0x" << hex << jtagid << endl;

		// init communication
		jtag->reset_jtag();
		jtag->HICANN_set_pll_far_ctrl(ms, ns, pdn, frg, tst);
		dbg(0) << "Try Init() ..." ;
		if (hc->GetCommObj()->Init(hc->addr()) != Stage2Comm::ok) {
		 	dbg(0) << "ERROR: Init failed, abort" << endl;
			return 0;
		}
		dbg(0) << "Init() ok" << endl;


		// ******************************************************************
		// set up all background generators for fixed interval output
		// and forward to spl1/dnc_if 
		// ******************************************************************

		// merger configuration data...
		nc_merger mer[] = {BG0, BG1, BG2, BG3, BG4, BG5, BG6, BG7, L0_0, L0_1, L0_2, L0_3, L1_0, L1_1, L2_0,
			                   DNC0, DNC1, DNC2, DNC3, DNC4, DNC5, DNC6, DNC7};
		bool en[23] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; // all mergers act as static muxes
		bool se[23] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}; // all channels forward BEG data
		bool sl[23] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; // 'slow' operation is disabled because dnc_if accepts pulses in every cycle

		//initialize vector (required for stage2_hal functions) from arrays
		vector<nc_merger> merg  (mer, mer+sizeof(mer)/sizeof(nc_merger));
		vector<bool>      slow  (sl,  sl +sizeof(sl) /sizeof(bool));
		vector<bool>      select(se,  se +sizeof(se) /sizeof(bool));
		vector<bool>      enable(en,  en +sizeof(en) /sizeof(bool));

		// reset neuron control
		nc->nc_reset();

		// initialize merges (config defined above)
		//nc->merger_set(merg, enable, select, slow);
		nc->merger_set( BG0, 0, 1, 0);
		nc->merger_set(DNC0, 0, 0, 0);

		//configure all BEGs to spike every pulse_dist cycles (no Poisson)
		//nc->beg_configure(8, false, pulse_dist);
		nc->beg_configure(0, false, pulse_dist);

		// set neuron numbers in BEGs
		//for(uint i=0;i<8;i++) nc->beg_set_number(i,mynrns[i]);
		nc->beg_set_number(0,mynrns[0]);


		// ******************************************************************
		// turn on BEGs !!! -> decide which ones, here <- !!!
		// ******************************************************************
		//nc->beg_on(8);
		nc->beg_on(0);
	

		// ******************************************************************
		// configure SPL1 transfer directions
		// ******************************************************************

		// disable all DNC input at the final mergers (not neccessary since all mergers have been set up immediately after nc->reset())
		//nc->dnc_enable_set(0,0,0,0,0,0,0,0);

		// disable all loopback connections (just to be sure)
		nc->loopback_off(8);

		// configure SPL1 module !!! check what's neccessary for DNC interface !!!
		spc->write_cfg(0x100ff);  // bit 17 enables time stamp processing


		// ******************************************************************
		// configure DNC !!! check what's neccessary for DNC !!!
		// ******************************************************************
		dc->setTimeStampCtrl(0x00); // Enable timestamp Processing for HICANN 0 (assigned to bit 0)
		dc->setDirection(0x00);     // set transmission directions in DNC (for HICANN 0 only)
			

		// ******************************************************************
		// now start trace fifo and evaluate data... !!! check !!!
		// ******************************************************************

		jtag->HICANN_restart_time_counter();
		jtag->FPGA_set_systime_ctrl(1);
		// NOW activate SYS_START...

		jtag->FPGA_reset_tracefifo();
		jtag->FPGA_disable_pulsefifo();
		jtag->FPGA_disable_tracefifo();


		// start recording...
		jtag->FPGA_enable_tracefifo();

		// NOW activate SYS_START...
		
#ifdef NCSIM
		wait(1,SC_MS);
#else
		usleep(100000); //... ;-)
#endif		
		jtag->FPGA_disable_tracefifo();
		unsigned int rxtime;
		uint64_t jtag_recpulse;
		
		pFile = fopen("rx_pulses.txt","w");
		
		if(pFile == NULL) {
			printf("Error open FILE rx_pulses.txt\n");
			return 0;
		}
		
		fprintf(pFile,"RXTIME\tL1CHANNEL\tNRNID\tL1TIME\n");
		cout << "From trace FIFO received:" << endl;	
		while (!jtag->FPGA_empty_pulsefifo()) {
			jtag->FPGA_get_trace_fifo(rxtime,jtag_recpulse);
			/*cout << "At time:\t" << hex << rxtime;
			cout << " received Neuron number:\t" << dec << ((jtag_recpulse>>15) & 0x3f);
			cout << " from channel\t" << dec << ((jtag_recpulse>>21) & 0x7);
			cout << " with time:\t" << hex << (jtag_recpulse & 0x7fff) << endl;*/
			
			fprintf(pFile,"%i\t%i\t%i\t%i\n",rxtime,((unsigned int)(jtag_recpulse>>21) & 0x7),((unsigned int)(jtag_recpulse>>15) & 0x3f),((unsigned int)jtag_recpulse & 0x7fff));
		}
		
		
		fclose (pFile);
		// now evaluate data...


		return result;
	}
};


class LteeTmTimeStampTest : public Listee<Testmode>{
public:
	LteeTmTimeStampTest() : Listee<Testmode>(string("tmag_timestamp_test"), string("test time stamp processing using playback and trace fifo via SPL1 loopback in HICANN")){};
	Testmode * create(){return new TmTimeStampTest();};
};

LteeTmTimeStampTest ListeeTmTimeStampTest;

