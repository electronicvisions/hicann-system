// Company         :   kip
// Author          :   Andreas Gruebl
// E-Mail          :   agruebl@kip.uni-heidelberg.de
//
// Filename        :   synapse_control.h
// Project Name    :   p_facets
// Subproject Name :   s_hicann1
//
// Create Date     :   Tue Jun 24 08
// Last Change     :   Tue May 30 11
// by              :   akononov
//------------------------------------------------------------------------


#ifndef _SYNAPSE_CTRL_H_
#define _SYNAPSE_CTRL_H_

#include "config.h" // automatically generated by waf build flow, used for HICANN version stuff

#include "ctrlmod.h"
#include "logger.h"


namespace facets {

/** Encapsulates control functionality contained within synapse ram controller and STDP controllers
    See SystemVerilog file digitalStdpCtrl.sv as defined in HICANN specification (from BSCW server)
*/
class SynapseControl : public CtrlModule
{
public:

#if HICANN_V >= 2

	//synapse control constants
	enum sc_address {sc_encfg = 0x0,       //config SRAM
					sc_endrv  = 0x100,     //predrv SRAM
					sc_engmax = 0x200,     //gmax SRAM
					sc_scfg   = 0x500,     //timing SRAM
					sc_synw   = 0x600,     //synapse weight/decoder address space
					sc_regs   = 0x4000};   //register address space

	enum sc_regs {sc_ctrlreg   = 0x4000,   //control register
					sc_cnfgreg = 0x4001,   //config register
					sc_status  = 0x4002,   //status register
					sc_lut     = 0x4100,   //look-up table
					sc_synin   = 0x4200,   //SYNIN register
					sc_synout  = 0x4300,   //SYNOUT register
					sc_syncor  = 0x4400,   //SYNCORR register
					sc_synrst  = 0x4500};  //SYNRST register

	//STDP control ctrlreg bit definitions
	enum sc_ctrlreg {sc_cmd_p       = 0,   //command for digital stdp control
					sc_encr_p       = 4,   //enable correlation readback (saves power if not in use)
					sc_continuous_p = 5,   //continuous auto stdp
					sc_newcmd_p     = 6,   //for a new command, write cmd and newcmd=1
					sc_adr_p        = 8,   //target row, first row in auto stdp mode
					sc_lastadr_p    = 16,  //last row in auto stdp mode
					sc_colset_p     = 24,  //select column set
					sc_wo_reset     = 27,  //do not reset correlation
					sc_scc          = 28,  //assert scc signal
					sc_sca          = 29,  //assert sca signal
					sc_idle         = 30}; //is on when idle (read-only)

	//STDP control sequencer command codes
	enum sc_cmds {sc_cmd_idle       = 0,   //no active command
					sc_cmd_read     = 1,   //read weights from a column set into SYNIN register
					sc_cmd_st_dec   = 2,   //open one row for reading of decoder addresses
					sc_cmd_write    = 3,   //writes weights from SYNIN register to column set
					sc_cmd_auto     = 4,   //starts auto stdp
					sc_cmd_wdec     = 5,   //write decoder addresses from SYNIN register to column set
					sc_cmd_rdec     = 6,   //read decoder addresses from a column set into SYNIN register
					sc_cmd_st_rd    = 7,   //open one row for reading of synaptic weights
					sc_cmd_close    = 9,   //close row after reading
					sc_cmd_rst_corr = 10}; //reset correlation capacitors according to SYNRST register

	//configuration register bit definitions
	enum sc_cfg {sc_cfg_pattern1_p     = 0,    //correlation readout pattern
					sc_cfg_pattern2_p  = 4,    //correlation readout pattern
					sc_cfg_endel_p     = 8,    //number of enable clock cycles
					sc_cfg_predel_p    = 12,   //number of precharge delay clock cycles
					sc_cfg_gen_p       = 16,   //global enable bits for slices
					sc_cfg_dllresetb_p = 20,   //left/right synapse block dllresetb bit (active low)
					sc_cfg_oedel_p     = 22,   //number of output clock cycles
					sc_cfg_wrdel_p     = 26};  //number of write clock cycles

	//cbot: control/config bottom, ctop: top, pbot: predrive bottom, ptop: top, gmax top/bottom identical
	enum sc_sdctrl_top {sc_senx  = 1,
					sc_seni      = 2,
					sc_selgm0    = 4,
					sc_selgm1    = 8,
					sc_ctop_cap0 = 0x10,
					sc_ctop_cap1 = 0x20,
					sc_ctop_cap2 = 0x40,
					sc_ctop_dep  = 0x80};
	
	enum sc_sdctrl_bot {sc_cbot_topin = 0x10,
					sc_cbot_locin     = 0x20,
					sc_cbot_en        = 0x40,
					sc_cbot_enstdf    = 0x80};

	enum sc_sdgmax {sc_dac0_p = 0,
					sc_dac1_p = 4};

	enum sc_sdpredrv {sc_pbot_preout0_1_p   = 0,
						sc_pbot_preout2_3_p = 4};

	//status register bit definitions
	enum sc_status {sc_auto_busy=4,    //automatic weight update process active
					sc_slice_busy=2,   //synapse array busy
					sc_syndrv_busy=1}; //synapse driver busy

#elif HICANN_V == 1

	//synapse control constants...
	enum sc_address {sc_encfg=0x0,   //config SRAM
					sc_endrv=0x100, //predrv SRAM
					sc_engmax=0x200,//gmax SRAM
					sc_scfg=0x500,  //timing SRAM
					sc_regs=0x400,  //begin of register address space
					sc_synw=0x600}; //synapse weight/decoder address space

	enum sc_regs {sc_ctrlreg=sc_regs,
					sc_cnfgreg=sc_regs+1,
					sc_lut=sc_regs+2,
					sc_synd=sc_regs+6};

	//STDP control ctrlreg bit definitions
	enum sc_ctrlreg {sc_cmd_p=0,       //command for digital stdp control
					sc_encr_p=4,       //enable correlation readback (saves power if not in use)
					sc_continuous_p=5, //continuouse auto stdp
					sc_newcmd_p=6,     //for a new command, write cmd and newcmd=!newcmd
					sc_adr_p=8,        //target row, first row in auto stdp mode
					sc_lastadr_p=16};  //last row in auto stdp mode

	//STDP control sequencer command codes
	enum sc_cmds {sc_cmd_idle=0,        // no active command
					sc_cmd_read=1,		// reads correlation pattern and weights
					sc_cmd_proc=2,		// like READ, but performs one STDP cycle and updates weights
					sc_cmd_write=3,	    // writes weight register to synapse row
					sc_cmd_auto=4,		// starts auto stdp: PROC cycles from adr to lastadr
					sc_cmd_wdec=5,		// write weight register to synapse address decode
					sc_cmd_rdec=6,		// read synapse address decode in weight register
					sc_cmd_readpat=7,   // reads correlation pattern
					sc_cmd_readpatres=8};// reads correlation pattern and resets synapses

	enum sc_cfg {sc_cfg_pattern_p=0,    //2x4bit
				sc_cfg_endel_p=8,		//enable delay
				sc_cfg_predel_p=12, 	//precharge delay
				sc_cfg_gen_p=16, 		//global enable bits of synapse drivers
				sc_cfg_dllresetb_p=20}; //left/right synapse block dllresetb bit

	//cbot: control/config bottom, ctop: top, pbot: predrive bottom, ptop: top, gmax top/bottom identical
	enum sc_sdctrl_top {sc_senx=1,
					sc_seni=2,
					sc_selgm0=4,
					sc_selgm1=8,
					sc_ctop_cap0=0x10,
					sc_ctop_cap1=0x20,
					sc_ctop_cap2=0x40,
					sc_ctop_dep=0x80};
	
	enum sc_sdctrl_bot {sc_cbot_topin=0x10,
					sc_cbot_locin=0x20,
					sc_cbot_en=0x40,
					sc_cbot_enstdf=0x80};

	enum sc_sdgmax {sc_dac0_p=0, sc_dac1_p=4 };

	enum sc_sdpredrv {sc_pbot_preout0_1_p=0,
						sc_pbot_preout2_3_p=4};

#else
	#error Missing code for this HICANN revision.
#endif

	Logger& log; //!< reference to the global logger

	syn_loc loc; ///< synapse array location this instance corresponds to

	/// give pointer to utilized LinkLayer, start and range of this module's address range.
	SynapseControl(
		syn_loc sl,
		Stage2Ctrl* c,  //!< pointer to parent Stage2Ctrl class (i.e. HicannCtrl)
		uint ta, //!< associated OCP tagid 
		uint sa,
		uint ma);
	~SynapseControl();

	/// a function to configure the array, must be run from outside after the instance creation.
	void configure();

	/// like configure, but sets dllreset active. Run configure, when setup is finished
	void reset_dll();

	/// generate syndriver data by permuting data bits (HICANN error!!!) and shifting data for even rows.
	uint todriver(uint data, uint adr);

	/// generate "normal" data from syndriver data by permuting data bits (HICANN error!!!) and shifting data for even rows.
	uint fromdriver(uint sd, uint adr);

	/// reorganize the bits for the synapse decoder.
	void todecoder(uint &top, uint &bot);

	/// generate "normal" data from the synapse decoder data.
	void fromdecoder(uint &top, uint &bot);

	/// checks if synapse driver, array is busy or automatic update is running
	bool busy();

	/// checks if a automatic weight update is active/
	bool autobusy();

	/// checks if synapse array is busy.
	bool arraybusy();

	/// checks if a synapse driver is busy.
	bool driverbusy();

	/// returns the data under given register address.
	uint read_data(uint commaddr);

	/// writes data into given register.
	uint write_data(uint commaddr, uint writedata);

	/// write weights to trow, tcol.
	void write_weight(uint trow, uint tcol, uint val);

	/// read back weight from trow, tcol.
	uint read_weight(uint trow, uint tcol);

	/// write decoder values to trow, tcol.
	void write_decoder(uint trow, uint tcol, uint val);

	/// read back decoder value from trow, tcol.
	uint read_decoder(uint trow, uint tcol);

	/// write a row of weights.
	void write_weight(uint row, std::vector<uint> data);

	/// read a row of weights.
	void read_weight(uint row, std::vector<uint> &data);

	/// the correct way to write decoder values (uses both driver rows).
	void write_decoder(uint bot_row_adr, std::vector<uint> data_bot, std::vector<uint> data_top);

	/// the correct way to read decoder values (uses both driver rows).
	void read_decoder(uint bot_row_adr, std::vector<uint> &data_bot, std::vector<uint> &data_top);

	/// write a row of weights / decoder register values. decoder==false => write weights.
	/// WARNING: correct decoder values have to be encoded via todecoder() first
	void write_row(uint row, std::vector<uint> data, bool decoder);

	/// read a row of weights / decoder register values. decoder==false => read weights.
	/// WARNING: correct decoder values have to be extracted via fromdecoder()
	void read_row(uint row, std::vector<uint> &data, bool decoder);

	/// only resets the synapse drivers.
	void reset_drivers();

	/// only resets the synapse weights.
	void reset_weights();

	/// only resets the synapse decoders.
	void reset_decoders();

	/// reset synapse drivers and synapses to zero.
	void reset_all();

	/// configure synapse driver (driver number corresponds to the number of the bottom line of the driver).
	void drv_config(uint drv_nr, bool top_ex, bool top_in, bool bot_ex, bool bot_in, bool enable, bool loc_input, bool top_input);
	void drv_config(uint drv_nr, bool top_ex, bool top_in, bool bot_ex, bool bot_in, bool enable,
		bool loc_input, bool top_input, bool stdf_enable, bool dep, uint top_selgm, uint bot_selgm, uint cap);

	/// write gmax values for synapse drivers (driver number corresponds to the number of the bottom line of the driver).
	/// selbot/seltop - select floating gate value (0-3), fracbot/fractop - select divider (1-15)
	void drv_set_gmax(uint drv_nr, uint selbot, uint seltop, uint fracbot, uint fractop);
	//both dividers (for inhibitory/excitatory input of a row are made equal
	void gmax_frac_set(uint drv_nr, uint fracbot, uint fractop);
	//both dividers set separately
	void gmax_frac_set(uint drv_nr, uint fracbotexc, uint fracbotinh, uint fractopexh, uint fractopinh);

	/// write predrv values for synapse drivers (driver number corresponds to the number of the bottom line of the driver).
	void drv_set_pdrv(uint drv_nr, uint pdrvbot, uint pdrvtop);

	/// set preout encoding with two upper neuron address bits (only 2 bits valid in poutX: [1..0]=[na[5]..na[4]]).
	void preout_set(uint drv_nr, uint pout0, uint pout1, uint pout2, uint pout3);

	/// reads out the driver registers and writes them into provided variables
	void read_driver(uint addr, uint &cfgbot, uint &pdrvbot, uint &gmaxbot, uint &cfgtop, uint &pdrvtop, uint &gmaxtop);

	/// prints the driver configuration of all drivers.
	void print_config();

	/// prints all weights of all lines.
	void print_weight();

	/// prints all decoders of all lines.
	void print_decoder();

	/// sets timing parameters of full-custom SRAM controller
	void set_sram_timings(
		uint read_delay,      //! 8 Bit, chip default (V2/4): 8 | read delay (data valid after this time)
		uint setup_precharge, //! 4 Bit, chip default (V2/4): 1 | setup time for address lines and (data (write) or precharge (read))
		uint write_delay      //! 4 Bit, chip default (V2/4): 1 | actual write time
			);

	/// reads back timing parameters of full-custom SRAM controller from chip and sets values to referenced variables
	void get_sram_timings(
		uint& read_delay,      //! 8 Bit, read delay (data valid after this time)
		uint& setup_precharge, //! 4 Bit, setup time for address lines and (data (write) or precharge (read))
		uint& write_delay      //! 4 Bit, actual write time
			);

private:
	/** @brief encapsulate all common ctor stuff
	 * @note must be called by every ctor
	 */
	void init();
};

}  // end of namespace facets

#endif

